---
title: "Loutre_analyse_GLMM"
author: "Pablo"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
#  bookdown::word_docume
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, warning = FALSE, message = FALSE)
```

# Probl√©matique du stage 

Je travaille sur un jeu de donn√©es d‚Äôun protocole de suivi de la loutre d‚ÄôEurope sur 10 ans (environ 400 donn√©e), sur le bassin-versant c√¥tier entre la baie de Lannion et Morlaix (**Secteur j25**).

Le protocole a pour but de s‚Äôappliquer √† une √©chelle locale, d‚Äôun bassin-versant en consid√©rant un secteur de 60 sites s√©lectionn√©s favorable au marquage (√©preinte) de la loutre. 

Un passage est effectu√© chaque ann√©e au printemps.

L‚Äôobjectif de mon stage est de **d√©terminer si ce protocole permet de d√©tecter des variations temporelles de l‚Äôintensit√© de marquage, √† l‚Äô√©chelle des agr√©gats de 60 sites**. En cela, il serait un indicateur de l‚Äô√©volution de l‚Äô√©tat de la population, c‚Äôest le postulat de d√©part.


# Importation des packages

```{r}
library(tidyverse)
library(gridExtra)
library(lubridate)
library(sf)
library(mapview)
library(maptiles)
library(tidyterra)
library(kableExtra)
library(knitr)
library(RVAideMemoire)
library(emmeans)
library(car)
library(MASS)
library(lme4)
library(MuMIn)
library(janitor)
library(purrr)

```

# Importation des donn√©es - Secteur J25 : Petit Tregor 

```{r}
base_tregor <-
  readxl::read_xlsx(path = '../raw_data/export_suiviloutrelocal_telecharger_csv_2025_04_03_10h58m17.xlsx') %>%
  dplyr::select(
    id_dataset,
    code_secteur,
    code_site,
    nom_site,
    x_l93,
    y_l93,
    date_visite,
    observateurs,
    condition_prospection,
    nom_taxon,
    nom_complet_taxon,
    techn_observation,
    statut_observation,
    nb_ep_tot,
    nb_ep_w,
    nb_ep_dnf,
    nb_ep_df
  ) %>%
  mutate(
    annee = year(date_visite),
    mois = month(date_visite),
    jour = day(date_visite),
    nb_ep_w = abs(nb_ep_w),
    statut_observation = ifelse(str_detect(statut_observation, '^Pr'), yes = 'Pr√©sent', no = 'Absent')
  ) %>% 
  filter(nom_complet_taxon =='Lutra lutra',
         !(id_dataset == 85 & code_secteur == "FR5300006"),
         code_secteur != "J401")
```

# Verifier les valeurs de la base de donn√©e 

## Jeu de donn√©es issus du Excel du prof de BTS avec correction 
```{r}
tregor_bts_correct <-
  readxl::read_xlsx(path = '../raw_data/data_brute_BTS.xlsx',
                    col_names = TRUE,
                    sheet = "analyse2 avec correct¬∞ coquille") %>%
  janitor::clean_names() %>%
  dplyr::select(
    site,
    nbre_empreintes_2011,
    nbre_empreintes_2012,
    nbre_empreintes_2014,
    nbre_empreintes_2016,
    nbre_empreintes_2017,
    nbre_empreintes_2018,
    nbre_empreintes_2019,
    nbre_empreintes_2023
  ) %>%
  dplyr::rename(code_site = site) %>%
  dplyr::filter(!is.na(code_site)) %>%
  dplyr::rename(
    "2011" = nbre_empreintes_2011,
    "2012" = nbre_empreintes_2012,
    "2014" = nbre_empreintes_2014,
    "2016" = nbre_empreintes_2016,
    "2017" = nbre_empreintes_2017,
    "2018" = nbre_empreintes_2018,
    "2019" = nbre_empreintes_2019,
    "2023" = nbre_empreintes_2023
  ) %>%
  dplyr::mutate(across(
    .cols = c("2011", "2012", "2014", "2016", "2017", "2018", "2019", "2023"),
    .fns = ~ ifelse(!is.na(.) & as.numeric(.) >= 1, 1, .)
  ))%>%
  mutate(across(
    c("2011", "2012", "2014", "2016", "2017", "2018", "2019", "2023"),
    ~ as.character(.)
  ))


```


```{r}
base_j25 <- base_tregor %>%
  filter(code_secteur == "J25") %>%
  mutate(statut_presence = ifelse(as.character(statut_observation) == "Pr√©sent", 1, 0))
```

## Jeu de donn√©es issus du Geonature 

```{r}
tregor_geonat_correct <- base_j25 %>%
  dplyr::mutate(statut_presence = as.factor(statut_presence),
                annee = as.factor(annee)) %>%
  dplyr::select(code_site, annee, statut_presence)
  #dplyr::distinct(code_site, annee, .keep_all = TRUE) %>%


```





V2
```{r}
# 1. Convertir tregor_bts_correct en format long
bts_long <- tregor_bts_correct %>%
  pivot_longer(
    cols = -code_site,
    names_to = "annee",
    values_to = "valeur_bts"
  ) %>%
  mutate(annee = as.character(annee),
         valeur_bts = as.character(valeur_bts))  # pour comparaison facile

# 2. Pr√©parer tregor_geonat_correct
geonat_clean <- tregor_geonat_correct %>%
  mutate(
    annee = as.character(annee),
    valeur_geonat = as.character(statut_presence)
  ) %>%
  dplyr::select(code_site, annee, valeur_geonat)

# 3. Joindre les deux sur code_site + annee
comparison_long <- bts_long %>%
  full_join(geonat_clean, by = c("code_site", "annee")) %>%
  filter(valeur_bts != valeur_geonat)

# 4. Afficher les √©carts
comparison_long

```

# V3 

```{r}
library(dplyr)
library(tidyr)

# √âtape 1 : r√©cup√©rer les sites et les ann√©es attendues
all_sites <- unique(tregor_bts_correct$code_site)
all_years <- c("2011", "2012", "2014", "2016", "2017", "2018", "2019", "2023")

# Cr√©er une grille compl√®te : 60 x 8 = 480 lignes attendues
grille_complete <- expand.grid(
  code_site = all_sites,
  annee = all_years,
  stringsAsFactors = FALSE
)

# √âtape 2 : transformer tregor_bts_correct en format long (apr√®s conversion des colonnes)
tregor_bts_long <- tregor_bts_correct %>%
  mutate(across(all_of(all_years), ~ as.character(.))) %>%
  pivot_longer(
    cols = all_of(all_years),
    names_to = "annee",
    values_to = "valeur_bts"
  )

# √âtape 3 : joindre √† la grille compl√®te et ajouter les NA
bts_long_complet <- grille_complete %>%
  left_join(tregor_bts_long, by = c("code_site", "annee"))

# Tu peux maintenant utiliser `bts_long_complet` pour la comparaison

```

```{r}
# Nettoyer tregor_geonat_correct (d√©j√† en long)
geonat_clean <- tregor_geonat_correct %>%
  mutate(
    annee = as.character(annee),
    valeur_geonat = as.character(statut_presence)
  ) %>%
  dplyr::select(code_site, annee, valeur_geonat)

# Comparaison
comparison_long <- bts_long_complet %>%
  full_join(geonat_clean, by = c("code_site", "annee")) %>%
  filter(valeur_bts != valeur_geonat)

# Affichage
comparison_long


# 
comparison_summary <- bts_long_complet %>%
  full_join(geonat_clean, by = c("code_site", "annee")) %>%
  mutate(
    comparaison = case_when(
      is.na(valeur_bts) & is.na(valeur_geonat) ~ "Tous NA",
      is.na(valeur_bts) ~ "NA dans bts uniquement",
      is.na(valeur_geonat) ~ "NA dans geonat uniquement",
      valeur_bts != valeur_geonat ~ "Diff√©rentes",
      TRUE ~ "Identiques"
    )
  ) %>%
  count(comparaison)

comparison_summary

```


####

# Repr√©sentation cartographique du secteur d'√©tude et des sites correspondants

```{r, fig.cap="",fig.width = 7, fig.height = 5}
sites_geo <- base_tregor %>% 
  filter(code_secteur == "J25") %>%
  dplyr::select(nom_site:y_l93,
         statut_observation,
         code_secteur,
         annee) %>% 
  sf::st_as_sf(coords = c("x_l93", "y_l93"),
               crs = sf::st_crs(2154))
 
mapview::mapview(sites_geo, 
                 zcol = "code_secteur",
                 col.regions = c("FR5300006" = "indianred1", 
                                 "J25" = "darkseagreen3") 
)
```



#  Mod√®le 1 : Le statut d'observation depend de l'ann√©e


## Construction du mod√®le 


### **Definition des types de variables**

+ **Variable r√©ponse** : Statut_pr√©sence, variable qualitative binaire, nominale 
+ **Variable explicative** : 
+ Annee, variable quantitative 
+ Site, variable qualitative ordinale 

### **Choix de la distribution de r√©f√©rence**

 => **Distribution Binomiale**


### **Choix de la fonction de lien**

=> **logit** 

### **Mod√®le mixte**


```{r}
mod3.0 <- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "logit"), data = base_j25)
```

##  V√©rification de l‚Äôajustement du mod√®le aux donn√©es


* **V√©rification de la lin√©arit√© du mod√®le**

```{r, fig.cap="",fig.width = 7, fig.height = 5}
plotresid(mod3.0)

```

La relation ne semble pas lin√©aire, il y a une structuration dans les r√©sidus
autrement dit d√©pendance entre les valeurs pr√©dites (ùúá) et les r√©sidus (ùúÄ).

### **Remplacer la fonction de lien "logit" par "probit"**

```{r}
mod3.1 <- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "probit"), data = base_j25)
```


**V√©rification de l'ind√©pendance des r√©sidus**

```{r, fig.cap="",fig.width = 7, fig.height = 5}
plotresid(mod3.1)

```

La relation ne semble pas lin√©aire, il y a une structuration dans les r√©sidus
autrement dit d√©pendance entre les valeurs pr√©dites (ùúá) et les r√©sidus (ùúÄ).

### **Remplacer la fonction de lien "logit" par "cauchit"**

```{r}
mod3.2 <- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "cauchit"), data = base_j25)
```


**V√©rification de l'ind√©pendance des r√©sidus**
```{r, fig.cap="",fig.width = 7, fig.height = 5}

plotresid(mod3.2)

```

La relation semble lin√©aire, il n‚Äôy a pas une structuration dans les r√©sidus
autrement dit ind√©pendance entre les valeurs pr√©dites (ùúá) et les r√©sidus (ùúÄ).


## Capacit√© explicative globale

** La fonction ne semble pas vouloir fonctionner lorsque la fonction de lien "cauchit" est utilis√© 

```{r}
r.squaredGLMM(mod3.0)

```
```{r}
r.squaredGLMM(mod3.1)

```


**Valeur des coefficients (estimate)**

```{r}
summary(mod3.2)
```
Ann√©e est une co-variable, on regarde  les valeurs des coefficients "Estimate" (valeur du parametre donc de la pente). La relation est donc √† la **diminution du taux de pr√©sence par site** et **significative**, 5.306e-02 < 0,05.


## Exploitation du mod√®le

### **Test de Wald**

```{r}
Anova(mod3.2)
```
##  Mod√®le 4 : Le statut d'observation depend de l'ann√©e


```{r}
summary(base_j25)
```

```{r}
base_j25_year_factor <- base_tregor %>%
  filter(code_secteur == "J25")%>%
  mutate(statut_presence = ifelse(as.character(statut_observation) == "Pr√©sent", 1, 0), 
         annee = as.factor(annee), 
         code_site = as.factor(code_site))

```

```{r}
summary(base_j25_year_factor)

```

### Construction du mod√®le 


#### **Definition des types de variables**

+ **Variable r√©ponse** : Statut_pr√©sence, variable qualitative binaire, nominale 
+ **Variable explicative** : 
+ Annee, variable qualitative ordinale 
+ Site, variable qualitative ordinale 

#### **Choix de la distribution de r√©f√©rence**

 => **Distribution Binomiale**


#### **Choix de la fonction de lien**

=> **logit** 

#### **Mod√®le mixte**


```{r}
mod4.0<- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "logit"), data = base_j25_year_factor)
```

###  V√©rification de l‚Äôajustement du mod√®le aux donn√©es


**V√©rification de l'ind√©pendance des r√©sidus**

```{r, fig.cap="",fig.width = 7, fig.height = 5}
plotresid(mod4.0)

```


#### **Remplacer la fonction de lien "logit" par "cauchit"**
```{r}
mod4.1<- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "cauchit"), data = base_j25_year_factor)
```

###  V√©rification de l‚Äôajustement du mod√®le aux donn√©es


**V√©rification de l'ind√©pendance des r√©sidus**
```{r, fig.cap="",fig.width = 7, fig.height = 5}
plotresid(mod4.1)

```
**Valeur des coefficients (estimate)**

```{r}
summary(mod4.1)
```


### Exploitation du mod√®le

#### **Test de Wald**

```{r}
Anova(mod4.1)

```

## Modele 6 : Retirer les Ann√©es avec des troues de prospections temporelles
```{r}
base_j25_year_factor <- base_tregor %>%
  filter(code_secteur == "J25", 
         annee == c(2017, 2018, 2019, 2023)) %>%
  mutate(statut_presence = ifelse(as.character(statut_observation) == "Pr√©sent", 1, 0), 
         annee = as.factor(annee), 
         code_site = as.factor(code_site))

```

### Construction du mod√®le 


#### **Definition des types de variables**

+ **Variable r√©ponse** : Statut_pr√©sence, variable qualitative binaire, nominale 
+ **Variable explicative** : 
+ Annee, variable qualitative ordinale 
+ Site, variable qualitative ordinale 

#### **Choix de la distribution de r√©f√©rence**

 => **Distribution Binomiale**


#### **Choix de la fonction de lien**

=> **logit** 

#### **Mod√®le mixte**


```{r}
mod6.0<- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "logit"), data = base_j25_year_factor)
```

###  V√©rification de l‚Äôajustement du mod√®le aux donn√©es


**V√©rification de l'ind√©pendance des r√©sidus**

```{r, fig.cap="",fig.width = 7, fig.height = 5}
plotresid(mod6.0)

```


#### **Remplacer la fonction de lien "logit" par "cauchit"**
```{r}
mod6.1<- glmer(statut_presence~annee+(1|code_site), family=binomial(link = "cauchit"), data = base_j25_year_factor)
```

###  V√©rification de l‚Äôajustement du mod√®le aux donn√©es


**V√©rification de l'ind√©pendance des r√©sidus**
```{r, fig.cap="",fig.width = 7, fig.height = 5}
plotresid(mod6.1)

```
**Valeur des coefficients (estimate)**

```{r}
summary(mod6.1)
```


